from Cryptodome.Hash import SHA1
from Cryptodome.Random import get_random_bytes
from Cryptodome.Cipher import PKCS1_OAEP
from Cryptodome.PublicKey import RSA
from Cryptodome.Cipher import AES
import base64
import json

import vault_backend
import config
from hyok_logging import logger

# This script implements: https://help.salesforce.com/articleView?id=security_pe_byok_cache_create.htm&type=5


def get_wrapped_key_as_jwe(jwt_token: str, tenant: str, jwe_kid: str, nonce: str = '') -> str:
    logger.info(f'Creating JWE token for request with kid "{jwe_kid}"...')

    vault_path = config.get_vault_path_by_tenant_and_kid(tenant, jwe_kid)

    # TODO: walrus operator
    if not vault_path:
        # jwe kid not found in config,
        # assume kid and vault path are the same
        # and fetch latest version of secret
        vault_path = jwe_kid + ':latest'

    logger.debug(f'Fetching AES key for: {vault_path}')

    vault_key, key_version = vault_path.split(':')

    # Generate a 256-bit AES data encryption key. You can use the cryptographically secure method of your choice.
    # dek = get_random_bytes(32)  # 32 bytes * 8 = 256 bit -> AES256
    dek = vault_backend.get_dynamic_secret(vault_key, key_version, jwt_token)

    # TODO: walrus operator
    if not dek:
        logger.error('Cannot retrieve dek.')
        return ''

    if config.get_config_by_key('DEV_MODE'):
        logger.debug(f'Retrieved dek from Vault: {dek.hex()} (hex)')

    # Generate a 256-bit AES content encryption key using a cryptographically secure method.
    # The content encryption key (CEK) can be generated by the key consumer (e.g. Salesforce) or
    # by HYOK-Wrapper itself, which is why the CEK is sometimes also called BYOK key.
    # 32 bytes * 8 = 256 bit -> AES256
    cek = get_random_bytes(32)

    if config.get_config_by_key('DEV_MODE'):
        logger.debug(f'Generated cek (BYOK AES key): {cek.hex()} (hex)')

    # Generate and download your BYOK-compatible certificate.
    # key_consumer_cert: public certificate from key consumer (e.g. Salesforce)
    key_consumer_cert_path = config.get_key_consumer_cert_by_tenant_and_kid(tenant, jwe_kid)

    if not key_consumer_cert_path:
        logger.error(
            f'Cannot find key consumer certificate for "{tenant}/{jwe_kid}". Configure it in config/config.json.')
        return ''

    with open(key_consumer_cert_path) as f:
        cert = f.read()

    if not cert:
        logger.error(f'Cannot read key consumer certificate at "{key_consumer_cert_path}".')
        return ''

    key_consumer_cert = RSA.importKey(cert)

    # Create the JWE protected header.
    # Encode the JWE protected header as BASE64URL(UTF8(JWE Protected Header)).
    protected_header = {'alg': 'RSA-OAEP', 'enc': 'A256GCM', 'kid': jwe_kid}

    if nonce:
        protected_header['jti'] = nonce

    b64_protected_header = base64.urlsafe_b64encode(json.dumps(protected_header).encode('utf-8'))

    # Encrypt the content encryption key with the public key from the key consumer certificate
    # using the RSAES-OAEP algorithm.
    # Then encode this encrypted content encryption key as BASE64URL(JWE Encrypted CEK Key).
    cek_cipher = PKCS1_OAEP.new(key_consumer_cert, hashAlgo=SHA1)
    cek_ciphertext = cek_cipher.encrypt(cek)
    b64_cek_ciphertext = base64.urlsafe_b64encode(cek_ciphertext)

    # Generate an initialization vector for use as input to the data encryption keyâ€™s AES wrapping.
    # Then encode it in base64url. BASE64URL(JWE Initialization Vector)
    # 12 bytes * 8 = 96 bit
    iv = get_random_bytes(12)
    b64_iv = base64.urlsafe_b64encode(iv)

    if config.get_config_by_key('DEV_MODE'):
        logger.debug(f'Generated IV/Nonce "{b64_iv.decode()}" (base64 encoded, bytes).')

    """
    Wrap your data encryption key with your content encryption key.

        Encode the JWE header as ASCII(BASE64URL(UTF8(JWE Protected Header))).
        Reform authenticated encryption on the data encryption key with the AES GCM algorithm.
            Use the content encryption key as the encryption key, the initialization vector,
            and the Additional Authenticated Data value,
            requesting a 128-bit Authentication Tag output.
        Encode the resulting ciphertext as BASE64URL(Ciphertext).
        Encode the Authentication Tag as BASE64URL(Authentication Tag).
    """
    # pyCryptoDome uses IV and NONCE interchangeably:
    #   - https://pycryptodome.readthedocs.io/en/latest/src/cipher/modern.html#modern-modes-of-operation-
    #       for-symmetric-block-ciphers

    # Additional authenticated data (aad)
    ascii_b64_protected_header = b64_protected_header.decode().encode('ascii', errors='strict')

    # mac_len=16: 128 bit authentication tag
    dek_cipher = AES.new(cek, AES.MODE_GCM, nonce=iv, mac_len=16)
    dek_cipher.update(ascii_b64_protected_header)
    # TODO: Autom. padding helpful?
    # from Cryptodome.Util.Padding import pad
    # encrypted_dek, tag = dek_cipher.encrypt_and_digest(pad(dek, AES.block_size))
    encrypted_dek, tag = dek_cipher.encrypt_and_digest(dek)

    b64_encrypted_dek = base64.urlsafe_b64encode(encrypted_dek)
    b64_tag = base64.urlsafe_b64encode(tag)

    if config.get_config_by_key('DEV_MODE'):
        logger.debug(
            f'Additional authenticated data (aad): {ascii_b64_protected_header.decode()}')
        logger.debug(
            f'Encrypted dek is "{encrypted_dek.hex()}" (hex) and tag is "{tag.hex()}" (hex).')

    # https://tools.ietf.org/html/rfc7516#section-3.3:
    #
    # BASE64URL(UTF8(JWE Protected Header)) || '.' ||
    # BASE64URL(JWE Encrypted Key) || '.' ||
    # BASE64URL(JWE Initialization Vector) || '.' ||
    # BASE64URL(JWE Ciphertext) || '.' ||
    # BASE64URL(JWE Authentication Tag)
    jwe = b64_protected_header + b'.' + b64_cek_ciphertext + b'.' + b64_iv + b'.' + b64_encrypted_dek + b'.' + b64_tag

    jwe_token = {
        'kid': jwe_kid,
        'jwe': jwe.decode()
    }

    json_jwe_token = json.dumps(jwe_token)

    logger.debug(f'Created JWE token: {json_jwe_token}')

    # cleanup
    del dek
    del cek

    return json_jwe_token
